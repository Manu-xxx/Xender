/**
 * A {@link com.swirlds.virtualmap.VirtualKey} implements two sets of serialization methods. The
 * methods that take a {@link java.nio.ByteBuffer} ({@link #serialize(ByteBuffer)} and {@link
 * #deserialize(ByteBuffer, int)}) are called by the {@link
 * com.hedera.node.app.state.merkle.disk.OnDiskKeySerializer} when working with the database. The
 * other serialization methods ({@link #serialize(SerializableDataOutputStream)} and {@link
 * #deserialize(SerializableDataInputStream, int)}) are called for hashing, reconnect, and state
 * saving and loading. Even though a virtual key is saved on disk, it may be that it is in memory at
 * the time of reconnect or state saving, and is definitely in memory at the time of hashing, so
 * these methods need to be implemented as well.
 *
 * <p>In all cases, the serialization methods delegate to the {@link
 * com.hedera.node.app.spi.state.Serdes} to do the actual work. However, the {@link
 * com.hedera.node.app.spi.state.Serdes} object itself is *NOT* serializable, and is not stored in
 * state. This presents an extra complication at startup. When we start up, we start reading the
 * saved state on disk. We read an object at a time. There is a unique 'classId' saved to disk for
 * each unique type of object. In our case, we don't want the 'classId' to be based on {@link
 * com.hedera.node.app.state.merkle.disk.OnDiskKey}, but on the type represented by this class (such
 * as AccountID). We do this by generating a classId based on the schema version, service name,
 * state key, AND {@link com.hedera.node.app.state.merkle.disk.OnDiskKey} type. This is generated by
 * the {@link com.hedera.node.app.state.merkle.MerkleSchemaRegistry} at the time that {@link
 * com.hedera.node.app.spi.state.Schema}s are registered, so this information is available at the
 * time the key is loaded.
 */
package com.hedera.node.app.state.merkle.disk;

import com.swirlds.common.io.streams.SerializableDataInputStream;
import com.swirlds.common.io.streams.SerializableDataOutputStream;
import java.nio.ByteBuffer;
